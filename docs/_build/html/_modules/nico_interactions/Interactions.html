<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>nico_interactions.Interactions &mdash; NiCo 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=8d563738"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/nico-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html#tutorials">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">NiCo_Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions (FAQ)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NiCo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">nico_interactions.Interactions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for nico_interactions.Interactions</h1><div class="highlight"><pre>
<span></span>

<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Voronoi</span><span class="p">,</span> <span class="n">ConvexHull</span><span class="p">,</span><span class="n">voronoi_plot_2d</span><span class="p">,</span> <span class="n">Delaunay</span>

<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_classification</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span><span class="p">,</span><span class="n">LogisticRegressionCV</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RandomizedSearchCV</span><span class="p">,</span><span class="n">GridSearchCV</span><span class="p">,</span><span class="n">cross_val_predict</span><span class="p">,</span> <span class="n">cross_val_score</span><span class="p">,</span><span class="n">RepeatedStratifiedKFold</span><span class="p">,</span><span class="n">StratifiedShuffleSplit</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">make_scorer</span><span class="p">,</span><span class="n">accuracy_score</span><span class="p">,</span> <span class="n">f1_score</span><span class="p">,</span> <span class="n">classification_report</span><span class="p">,</span><span class="n">confusion_matrix</span><span class="p">,</span><span class="n">roc_curve</span><span class="p">,</span> <span class="n">roc_auc_score</span><span class="p">,</span> <span class="n">precision_score</span><span class="p">,</span> <span class="n">recall_score</span><span class="p">,</span> <span class="n">precision_recall_curve</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PolynomialFeatures</span><span class="p">,</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="c1">#from sklearn.metrics import precision_recall_fscore_support as score</span>
<span class="c1">#from imblearn.over_sampling import SMOTE, SMOTEN,ADASYN, KMeansSMOTE, SVMSMOTE</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">class_weight</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span><span class="p">,</span> <span class="n">auc</span>

<span class="c1">#Metrics</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">cohen_kappa_score</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">hamming_loss</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">log_loss</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">zero_one_loss</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">matthews_corrcoef</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">snn</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="c1">#import time</span>
<span class="c1">#import pickle5 as pickle</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="kn">import</span> <span class="n">dendrogram</span><span class="p">,</span> <span class="n">linkage</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span><span class="p">,</span> <span class="n">LinearSegmentedColormap</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">SimpleNamespace</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="c1">#export PYTHONWARNINGS=&#39;ignore:Multiprocessing-backed parallel loops:UserWarning&#39;</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;PYTHONWARNINGS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;ignore::UserWarning&quot;</span>





<div class="viewcode-block" id="create_directory">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.create_directory">[docs]</a>
<span class="k">def</span> <span class="nf">create_directory</span><span class="p">(</span><span class="n">outputFolder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an empty directory.</span>

<span class="sd">    This function checks if a specified directory exists, and if not, it creates the directory.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    outputFolder : str</span>
<span class="sd">        The path of the directory to be created.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    OSError</span>
<span class="sd">        If the directory cannot be created due to permission issues or other OS-related errors.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If the directory already exists, no action is taken.</span>
<span class="sd">    - This function ensures that the directory path is available for subsequent file operations.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; create_directory(&#39;./new_out/&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">answer</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outputFolder</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">answer</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outputFolder</span><span class="p">)</span></div>


<div class="viewcode-block" id="findNeighbors_in_given_radius">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.findNeighbors_in_given_radius">[docs]</a>
<span class="k">def</span> <span class="nf">findNeighbors_in_given_radius</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the neighbors for each cell using the given radius.</span>

<span class="sd">    This helper function used in ``create_spatial_CT_feature_matrix`` identifies the neighboring cells for each cell within the specified</span>
<span class="sd">    radius and computes the average distance to these neighbors.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    location : np.ndarray</span>
<span class="sd">        An array of shape (n, 3) representing the coordinates of the cells.</span>
<span class="sd">    radius : float</span>
<span class="sd">        The radius within which to search for neighboring cells.</span>
<span class="sd">        For immediate neighbors it is 0</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    list</span>
<span class="sd">        A list of lists where each sublist contains the indices of the neighbors for each cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span><span class="o">=</span><span class="n">location</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#print(&#39;ss&#39;,location.shape)</span>
    <span class="n">neighbor</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">mydist</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">mycount</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">loc1</span><span class="o">=</span><span class="n">location</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1">#print(i,loc1)</span>
        <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="n">loc1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">1.1</span><span class="o">*</span><span class="n">radius</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">location</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t2</span><span class="o">=</span><span class="n">location</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">loc1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">1.1</span><span class="o">*</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="n">loc1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">1.1</span><span class="o">*</span><span class="n">radius</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">location</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t4</span><span class="o">=</span><span class="n">location</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">loc1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">1.1</span><span class="o">*</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">loc1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mf">1.1</span><span class="o">*</span><span class="n">radius</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">location</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">t6</span><span class="o">=</span><span class="n">location</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">loc1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mf">1.1</span><span class="o">*</span><span class="n">radius</span><span class="p">)</span>

        <span class="n">index</span><span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">where</span> <span class="p">(</span> <span class="n">t1</span> <span class="o">&amp;</span> <span class="n">t2</span> <span class="o">&amp;</span> <span class="n">t3</span> <span class="o">&amp;</span> <span class="n">t4</span> <span class="o">&amp;</span> <span class="n">t5</span> <span class="o">&amp;</span> <span class="n">t6</span>    <span class="p">)</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">j</span><span class="o">=</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="n">i</span><span class="p">:</span>
                <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">loc2</span><span class="o">=</span><span class="n">location</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">dist</span><span class="o">=</span><span class="n">euclidean_dist</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span><span class="n">loc2</span><span class="p">)</span>
                <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">if</span> <span class="n">dist</span><span class="o">&lt;</span><span class="n">radius</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="p">:</span>
                        <span class="n">neighbor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">neighbor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                            <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>

                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="p">:</span>
                        <span class="n">neighbor</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="n">neighbor</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>

                    <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">mydist</span><span class="o">=</span><span class="n">mydist</span><span class="o">+</span><span class="n">dist</span>
                        <span class="n">mycount</span><span class="o">=</span><span class="n">mycount</span><span class="o">+</span><span class="mi">1</span>

        <span class="c1">#print(&#39;t&#39;,count,len(index[0]))</span>


    <span class="n">newneig</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">avg_neigh</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">l</span><span class="o">=</span><span class="n">neighbor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">l</span><span class="o">=</span><span class="p">[]</span>
        <span class="c1">#print(l)</span>
        <span class="n">newneig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">avg_neigh</span><span class="o">+=</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;average neighbors:&#39;</span><span class="p">,</span><span class="n">avg_neigh</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;average distance:&#39;</span><span class="p">,</span><span class="n">mydist</span><span class="o">/</span><span class="n">mycount</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newneig</span></div>



<div class="viewcode-block" id="find_neighbors">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.find_neighbors">[docs]</a>
<span class="k">def</span> <span class="nf">find_neighbors</span><span class="p">(</span><span class="n">pindex</span><span class="p">,</span> <span class="n">triang</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the neighbors for a given point index using Delaunay triangulation.</span>

<span class="sd">    This helper function used in ```create_spatial_CT_feature_matrix``` identifies the neighboring points (cells) for a given point index</span>
<span class="sd">    using the Delaunay triangulation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    pindex : int</span>
<span class="sd">        The index of the point (cell) for which neighbors are to be found.</span>
<span class="sd">    triang : scipy.spatial.Delaunay</span>
<span class="sd">        The Delaunay triangulation of the point set.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        An array of indices representing the neighbors of the given point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">triang</span><span class="o">.</span><span class="n">vertex_neighbor_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">triang</span><span class="o">.</span><span class="n">vertex_neighbor_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">pindex</span><span class="p">]:</span><span class="n">triang</span><span class="o">.</span><span class="n">vertex_neighbor_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">pindex</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span></div>



<div class="viewcode-block" id="create_spatial_CT_feature_matrix">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.create_spatial_CT_feature_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">create_spatial_CT_feature_matrix</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span><span class="n">PP</span><span class="p">,</span><span class="n">louvain</span><span class="p">,</span><span class="n">noct</span><span class="p">,</span><span class="n">fraction_CT</span><span class="p">,</span><span class="n">saveSpatial</span><span class="p">,</span><span class="n">epsilonThreshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the expected spatial cell type neighborhood matrix.</span>

<span class="sd">    This helper function is used in spatial_neighborhood_analysis to create a matrix that represents</span>
<span class="sd">    the expected neighborhood cell type composition based on spatial data. It uses either a radius-based</span>
<span class="sd">    approach or Delaunay triangulation to determine neighboring cells.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radius : float</span>
<span class="sd">        Radius within which to find neighbors. If set to 0, Delaunay triangulation is used instead.</span>
<span class="sd">    PP : np.ndarray</span>
<span class="sd">        Array of spatial coordinates of cells. Shape (n_cells, n_dimensions).</span>
<span class="sd">    louvain : np.ndarray</span>
<span class="sd">        Array containing Louvain clustering results for each cell. Shape (n_cells, 1).</span>
<span class="sd">    noct : int</span>
<span class="sd">        Number of cell types.</span>
<span class="sd">    fraction_CT : list of float</span>
<span class="sd">        List representing the fraction of each cell type.</span>
<span class="sd">    saveSpatial : str</span>
<span class="sd">        Path to save the output file containing the normalized spatial neighborhood matrix.</span>
<span class="sd">    epsilonThreshold : float</span>
<span class="sd">        Threshold distance cutoff to limit the distant neighbors when using Delaunay triangulation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        - M : int</span>
<span class="sd">            Placeholder for future calculations (currently always returns 0).</span>
<span class="sd">        - neighbors : list of list of int</span>
<span class="sd">            List of neighbors for each cell. Each sublist contains indices of neighboring cells.</span>
<span class="sd">        - distance : list of list of float</span>
<span class="sd">            List of distances to neighbors for each cell. Each sublist contains distances to the neighboring cells.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If radius is set to 0, Delaunay triangulation is used to find the neighbors within the epsilonThreshold distance.</span>
<span class="sd">    - The function saves the normalized spatial neighborhood matrix as a .npz file at the specified location.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="n">radius</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">PP</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">PP</span><span class="o">=</span><span class="n">PP</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">PP</span><span class="p">)</span>
        <span class="n">newneig</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">avg_neigh</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="n">mydist</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">mycount</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">PP</span><span class="p">)):</span>
            <span class="n">ol</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">tri</span><span class="p">)</span>
            <span class="n">l</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">temp</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ol</span><span class="p">)):</span>
                <span class="n">dist</span><span class="o">=</span><span class="n">euclidean_dist</span><span class="p">(</span><span class="n">PP</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">PP</span><span class="p">[</span><span class="n">ol</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span><span class="o">&lt;</span><span class="n">epsilonThreshold</span><span class="p">:</span>
                    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ol</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">mydist</span><span class="o">=</span><span class="n">mydist</span><span class="o">+</span><span class="n">dist</span>
                    <span class="n">mycount</span><span class="o">=</span><span class="n">mycount</span><span class="o">+</span><span class="mi">1</span>
                <span class="c1">#print(i,j,dist,PP[i],PP[l[j]])</span>
            <span class="c1">#print(PP[i,l)</span>
            <span class="c1">#if len(l)!=len(ol):</span>
            <span class="c1">#    print(i,type(ol),ol,l,temp,&#39;\n&#39;)</span>
            <span class="n">newneig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">avg_neigh</span><span class="o">+=</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;average neighbors:&#39;</span><span class="p">,</span><span class="n">avg_neigh</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">PP</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;average distance:&#39;</span><span class="p">,</span><span class="n">mydist</span><span class="o">/</span><span class="n">mycount</span><span class="p">)</span>
        <span class="n">neighbors</span><span class="o">=</span><span class="n">newneig</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">neighbors</span><span class="o">=</span><span class="n">findNeighbors_in_given_radius</span><span class="p">(</span><span class="n">PP</span><span class="p">,</span><span class="n">radius</span><span class="p">)</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>

    <span class="n">expectedNeighbors</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">input_mat_for_log_reg</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">cell1</span><span class="o">=</span><span class="n">i</span>
        <span class="n">CT1</span><span class="o">=</span><span class="n">louvain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">V</span><span class="o">=</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">temp</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">CT2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">noct</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)):</span>
            <span class="n">name</span><span class="o">=</span><span class="n">louvain</span><span class="p">[</span><span class="n">V</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">CT2</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">+=</span><span class="mf">1.0</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1">#fw.write(str(cell1)+&#39;\t&#39;+str(CT1))</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell1</span><span class="p">)</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CT1</span><span class="p">)</span>
        <span class="n">expected</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fraction_CT</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">CT2</span><span class="p">)</span>
        <span class="n">tt</span><span class="o">=</span><span class="n">CT1</span>
        <span class="c1">#print(np.concatenate(np.array(celltype[key]),CT2))</span>
        <span class="n">expectedNeighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">tt</span><span class="p">]),</span><span class="n">CT2</span><span class="p">]))</span>
        <span class="c1">#print(expectedNeighbors)</span>
        <span class="n">CT2</span><span class="o">=</span><span class="n">CT2</span><span class="o">/</span><span class="n">expected</span>   <span class="c1">#np.sum(CT2) #np.linalg.norm(CT2)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">CT2</span><span class="p">:</span>
            <span class="c1">#fw.write(&#39;\t&#39;+&#39;%0.5f&#39;%j)</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="c1">#fw.write(&#39;\n&#39;)</span>
        <span class="n">input_mat_for_log_reg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

    <span class="n">input_mat_for_log_reg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_mat_for_log_reg</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">saveSpatial</span><span class="o">+</span><span class="s1">&#39;normalized_spatial_neighborhood_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span><span class="n">input_mat_for_log_reg</span><span class="o">=</span><span class="n">input_mat_for_log_reg</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    expectedNeighbors=np.array(expectedNeighbors)</span>
<span class="sd">    M=[]</span>
<span class="sd">    for i in range(len(noct)):</span>
<span class="sd">        a=np.where(expectedNeighbors[:,0]==i)</span>
<span class="sd">        b=np.where(expectedNeighbors[:,0]!=i)</span>
<span class="sd">        #print(&#39;a&#39;,len(a[0]),len(b[0]))</span>
<span class="sd">        myCT=np.mean(expectedNeighbors[a[0],1:],axis=0)</span>
<span class="sd">        remainCT=np.mean(expectedNeighbors[b[0],1:],axis=0)</span>
<span class="sd">        M.append(myCT/remainCT)</span>
<span class="sd">        #print(i,M[i])</span>
<span class="sd">    M=np.array(M)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">M</span><span class="o">=</span><span class="mi">0</span>

    <span class="n">distance</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)):</span>
        <span class="n">cc</span><span class="o">=</span><span class="n">louvain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p1</span><span class="o">=</span><span class="n">PP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">temp</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
            <span class="n">nid</span><span class="o">=</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">nc</span><span class="o">=</span><span class="n">louvain</span><span class="p">[</span><span class="n">nid</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p2</span><span class="o">=</span><span class="n">PP</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span>
            <span class="n">dist</span><span class="o">=</span><span class="n">euclidean_dist</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
            <span class="c1">#print(p1,p2,p1,nid,nc,dist)</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="c1">#print(i,cc,j,nid,p1,p2,dist)</span>
        <span class="n">distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">M</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span><span class="n">distance</span></div>






<div class="viewcode-block" id="euclidean_dist">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.euclidean_dist">[docs]</a>
<span class="k">def</span> <span class="nf">euclidean_dist</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span>
    <span class="s2">&quot;Calculate euclidean distance between two points in 2d/3d.&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>  <span class="o">+</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">p2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span></div>



<div class="viewcode-block" id="reading_data">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.reading_data">[docs]</a>
<span class="k">def</span> <span class="nf">reading_data</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span><span class="n">louvainFull</span><span class="p">,</span><span class="n">degbased_ctname</span><span class="p">,</span><span class="n">saveSpatial</span><span class="p">,</span><span class="n">removed_CTs_before_finding_CT_CT_interactions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function used in spatial_neighborhood_analysis to read the cell coordinate file,</span>
<span class="sd">    cluster file, and cluster name file according to the input cell type list provided for the prediction.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    coordinates : str</span>
<span class="sd">        Path to the file containing cell coordinates.</span>

<span class="sd">    louvainFull : str</span>
<span class="sd">        Path to the file containing the full louvain clustering information.</span>

<span class="sd">    degbased_ctname : list of tuples</span>
<span class="sd">        A list where each element is a tuple containing the cell type ID and the cell type name.</span>

<span class="sd">    saveSpatial : str</span>
<span class="sd">        Path where the spatial analysis results should be saved.</span>

<span class="sd">    removed_CTs_before_finding_CT_CT_interactions : list of str</span>
<span class="sd">        A list of cell type names that should be excluded from the analysis.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    CTname : list of str</span>
<span class="sd">        A list of cell type names that are included in the analysis after filtering out the removed cell types.</span>

<span class="sd">    CTid : list of int</span>
<span class="sd">        A list of cell type IDs corresponding to the filtered cell type names.</span>


<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - This function assumes that `degbased_ctname` is a list of tuples where the first element is an integer</span>
<span class="sd">      representing the cell type ID and the second element is a string representing the cell type name.</span>
<span class="sd">    - The function filters out the cell types listed in `removed_CTs_before_finding_CT_CT_interactions` from the</span>
<span class="sd">      `degbased_ctname` list and returns the remaining cell type names and IDs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#df=pd.read_csv(celltypeFilename)</span>
    <span class="c1">#data=df.to_numpy()</span>

    <span class="n">CTname</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">CTid</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degbased_ctname</span><span class="p">)):</span>
        <span class="n">name</span><span class="o">=</span><span class="n">degbased_ctname</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_CTs_before_finding_CT_CT_interactions</span><span class="p">:</span>
            <span class="n">CTname</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">CTid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">degbased_ctname</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    CTname=[]</span>
<span class="sd">    with open(celltypeFilename,&#39;r&#39;) as f:</span>
<span class="sd">        cont = f.read()</span>
<span class="sd">        lines=cont.split(&#39;\n&#39;)</span>
<span class="sd">        CTname=[]</span>
<span class="sd">        CTid=[]</span>
<span class="sd">        for i in range(1,len(lines)):</span>
<span class="sd">            l=lines[i].split(delimiter)</span>
<span class="sd">            if len(l)&gt;1:</span>
<span class="sd">                name=l[1]</span>
<span class="sd">                &#39;</span>
<span class="sd">                name=l[1].replace(&#39;/&#39;,&#39;_&#39;)</span>
<span class="sd">                name=name.replace(&#39; &#39;,&#39;_&#39;)</span>
<span class="sd">                name=name.replace(&#39;&quot;&#39;,&#39;&#39;)</span>
<span class="sd">                name=name.replace(&quot;&#39;&quot;,&#39;&#39;)</span>
<span class="sd">                name=name.replace(&#39;)&#39;,&#39;&#39;)</span>
<span class="sd">                name=name.replace(&#39;(&#39;,&#39;&#39;)</span>
<span class="sd">                name=name.replace(&#39;+&#39;,&#39;p&#39;)</span>
<span class="sd">                name=name.replace(&#39;-&#39;,&#39;n&#39;)</span>
<span class="sd">                name=name.replace(&#39;.&#39;,&#39;&#39;)</span>
<span class="sd">                &#39;</span>
<span class="sd">                if name not in removed_CTs_before_finding_CT_CT_interactions:</span>
<span class="sd">                    CTname.append(name)</span>
<span class="sd">                    CTid.append(int(l[0]))</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1">#CTid=data[:,0]</span>
    <span class="c1">#CTname=data[:,1]</span>

    <span class="c1">#df=pd.read_csv(clusterFilename,sep=delimiter)</span>
    <span class="c1">#louvainFull=df.to_numpy()</span>

    <span class="n">celltype</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">cellsinCT</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">index</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">louvainFull</span><span class="p">)):</span>
        <span class="n">clu_id</span><span class="o">=</span><span class="n">louvainFull</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cel_id</span><span class="o">=</span><span class="n">louvainFull</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">clu_id</span> <span class="ow">in</span> <span class="n">CTid</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1">#celltype[cel_id]=clu_id</span>
            <span class="k">if</span> <span class="n">clu_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cellsinCT</span><span class="p">:</span>
                <span class="n">cellsinCT</span><span class="p">[</span><span class="n">clu_id</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">cel_id</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cellsinCT</span><span class="p">[</span><span class="n">clu_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cel_id</span><span class="p">)</span>

    <span class="n">louvain</span><span class="o">=</span><span class="n">louvainFull</span><span class="p">[</span><span class="n">index</span><span class="p">,:]</span>
    <span class="n">points</span><span class="o">=</span><span class="n">coordinates</span>
    <span class="c1">#need to sort the coordinates according to louvain order of cells</span>
    <span class="n">temp</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span>

    <span class="n">index</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">louvain</span><span class="p">)):</span>
        <span class="nb">id</span><span class="o">=</span><span class="n">louvain</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="nb">id</span><span class="p">])</span>

    <span class="n">PP</span><span class="o">=</span><span class="n">points</span><span class="p">[</span><span class="n">index</span><span class="p">,:]</span>

    <span class="n">location_cellname2int</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">location_int2cellname</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">PP</span><span class="p">)):</span>
        <span class="n">name</span><span class="o">=</span><span class="n">PP</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">location_cellname2int</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
        <span class="n">location_int2cellname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">name</span>

    <span class="c1">#for 2d system</span>
    <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">PP</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">PP</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">PP</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">PP</span><span class="o">=</span><span class="n">points</span>
        <span class="n">tissue_dim</span><span class="o">=</span><span class="mi">2</span>

    <span class="c1">#for 3d system</span>
    <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
        <span class="n">PP</span><span class="o">=</span><span class="n">PP</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">tissue_dim</span><span class="o">=</span><span class="mi">3</span>


    <span class="c1">#print(&#39;louvain&#39;,louvain.shape,PP.shape)</span>

    <span class="n">noct</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">cellsinCT</span><span class="p">)</span>
    <span class="n">actual_count</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">fraction_CT</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">noct</span><span class="p">:</span>
        <span class="n">actual_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellsinCT</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="n">fraction_CT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellsinCT</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">louvainFull</span><span class="p">)))</span>

    <span class="c1">#print(&#39;no of cell types&#39;,len(noct))</span>

    <span class="n">temp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">actual_count</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">good_index_cell_counts</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#print(actual_count,noct[good_index_cell_counts])</span>

    <span class="n">less_no_cells_remove</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good_index_cell_counts</span><span class="p">)):</span>
        <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">louvain</span><span class="o">==</span><span class="n">noct</span><span class="p">[</span><span class="n">good_index_cell_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">less_no_cells_remove</span><span class="o">+=</span><span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1">#print(less_no_cells[0:10],len(louvain))</span>
    <span class="n">less_no_cells_remove</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">less_no_cells_remove</span><span class="p">)</span>


    <span class="n">PP</span><span class="o">=</span><span class="n">PP</span><span class="p">[</span><span class="n">less_no_cells_remove</span><span class="p">]</span>
    <span class="n">louvain</span><span class="o">=</span><span class="n">louvain</span><span class="p">[</span><span class="n">less_no_cells_remove</span><span class="p">]</span>
    <span class="c1">#print(&#39;louvain&#39;,louvain.shape,PP.shape)</span>

    <span class="n">new_CT_id</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good_index_cell_counts</span><span class="p">)):</span>
        <span class="n">new_CT_id</span><span class="p">[</span><span class="n">noct</span><span class="p">[</span><span class="n">good_index_cell_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span><span class="o">=</span><span class="n">i</span>
    <span class="c1">#print(&#39;a&#39;,np.unique(louvain))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">louvain</span><span class="p">)):</span>
        <span class="n">value</span><span class="o">=</span><span class="n">louvain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">louvain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">new_CT_id</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="c1">#print(value,louvain[i])</span>

    <span class="n">fw</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">saveSpatial</span><span class="o">+</span><span class="s1">&#39;used_CT.txt&#39;</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_CT_id</span><span class="p">)):</span>
            <span class="n">value</span><span class="o">=</span><span class="n">fraction_CT</span><span class="p">[</span><span class="n">good_index_cell_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">name</span><span class="o">=</span><span class="n">CTname</span><span class="p">[</span><span class="n">good_index_cell_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="c1">#print(CTname[key], key, total,len(cellsinCT[key]))</span>
            <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%0.4f</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">value</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">fw</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">louvainWithBarcodeId</span><span class="o">=</span><span class="n">louvain</span>
    <span class="n">louvain</span><span class="o">=</span><span class="n">louvain</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">PP</span><span class="p">,</span> <span class="n">louvain</span><span class="p">,</span> <span class="n">noct</span><span class="p">,</span><span class="n">fraction_CT</span><span class="p">,</span><span class="n">louvainWithBarcodeId</span></div>





<div class="viewcode-block" id="plot_multiclass_roc">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.plot_multiclass_roc">[docs]</a>
<span class="k">def</span> <span class="nf">plot_multiclass_roc</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the ROC (Receiver Operating Characteristic) curve for each cell type prediction</span>
<span class="sd">    and evaluate its performance on the test dataset.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    clf : classifier object</span>
<span class="sd">        The classifier used for making predictions. It should have a `decision_function` method.</span>

<span class="sd">    X_test : array-like of shape (n_samples, n_features)</span>
<span class="sd">        Test feature set.</span>

<span class="sd">    y_test : array-like of shape (n_samples,)</span>
<span class="sd">        True labels for the test set.</span>

<span class="sd">    n_classes : int</span>
<span class="sd">        Number of unique classes (cell types) in the dataset.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    fpr : dict</span>
<span class="sd">        A dictionary where the keys are class indices and the values are arrays of false positive rates.</span>

<span class="sd">    tpr : dict</span>
<span class="sd">        A dictionary where the keys are class indices and the values are arrays of true positive rates.</span>

<span class="sd">    roc_auc : dict</span>
<span class="sd">        A dictionary where the keys are class indices and the values are the area under the ROC curve (AUC) scores.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - This function uses the `decision_function` method of the classifier to get the confidence scores for each class.</span>
<span class="sd">    - The true labels `y_test` are converted into a binary format using one-hot encoding.</span>
<span class="sd">    - The ROC curve is computed for each class and the AUC score is calculated for each ROC curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y_score</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
    <span class="c1"># structures</span>
    <span class="n">fpr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">tpr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">roc_auc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="c1"># calculate dummies once</span>
    <span class="n">y_test_dummies</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">drop_first</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">):</span>
        <span class="n">fpr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tpr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test_dummies</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">y_score</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">roc_auc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">auc</span><span class="p">(</span><span class="n">fpr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tpr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">roc_auc</span></div>



<div class="viewcode-block" id="plot_confusion_matrix">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.plot_confusion_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">plot_confusion_matrix</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">5.5</span><span class="p">,</span><span class="mi">5</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate and save a confusion matrix plot from the results of spatial_neighborhood_analysis.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    input : dict, or similar object</span>
<span class="sd">        The main input is the output from spatial_neighborhood_analysis.</span>

<span class="sd">    saveas : str, optional, default=&#39;pdf&#39;</span>
<span class="sd">        Format to save the figure. Options are &#39;pdf&#39; or &#39;png&#39;. If &#39;png&#39;, the dpi is set to 300.</span>

<span class="sd">    showit : bool, optional, default=True</span>
<span class="sd">        Whether to display the plot after saving. If False, the plot will be closed after saving.</span>

<span class="sd">    transparent_mode : bool, optional, default=False</span>
<span class="sd">        Whether to save the figure with a transparent background.</span>

<span class="sd">    figsize : tuple of float, optional, default=(5.5, 5)</span>
<span class="sd">        Size of the figure in inches.</span>

<span class="sd">    Outputs:</span>
<span class="sd">    --------</span>
<span class="sd">    The function saves the confusion matrix plot in the directory specified by `nico_out/niche_prediction_linear/`.</span>
<span class="sd">    The filename will be in the format &#39;Confusing_matrix_R&lt;Radius&gt;.&lt;saveas&gt;&#39;, where &lt;Radius&gt; is the radius value</span>
<span class="sd">    from the input and &lt;saveas&gt; is the file format.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function loads data from a numpy file specified by `input.fout`, which should contain the confusion matrix</span>
<span class="sd">      and related data.</span>
<span class="sd">    - The confusion matrix is plotted using seaborn&#39;s heatmap function with annotations.</span>
<span class="sd">    - The plot is saved in the specified format and directory, and optionally displayed based on the `showit` parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">fout</span><span class="p">,</span><span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">coef</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef&#39;</span><span class="p">]</span>
    <span class="n">cmn</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn&#39;</span><span class="p">]</span>
    <span class="n">cmn_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn_std&#39;</span><span class="p">]</span>
    <span class="n">coef_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef_std&#39;</span><span class="p">]</span>
    <span class="n">CTFeatures</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;CTFeatures&#39;</span><span class="p">]</span>

    <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">classNames</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">classes</span><span class="p">)):</span>
        <span class="n">classNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="c1">#print(classes,nameOfCellType,inputFeatures)</span>
    <span class="n">snn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">cmn</span><span class="p">,</span><span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;.2f&#39;</span><span class="p">,</span><span class="n">xticklabels</span><span class="o">=</span><span class="n">classNames</span><span class="p">,</span> <span class="n">annot_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span><span class="n">yticklabels</span><span class="o">=</span><span class="n">classNames</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Predicted classes&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Truth classes&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;R = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, C=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lambda_c</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;Confusing_matrix_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;Confusing_matrix_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_coefficient_matrix">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.plot_coefficient_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">plot_coefficient_matrix</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate and save a coefficient matrix plot from the results of spatial_neighborhood_analysis.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    input : dict, or similar object</span>
<span class="sd">            The main input is the output from spatial_neighborhood_analysis.</span>

<span class="sd">    saveas : str, optional, default=&#39;pdf&#39;</span>
<span class="sd">        Format to save the figure. Options are &#39;pdf&#39; or &#39;png&#39;. If &#39;png&#39;, the dpi is set to 300.</span>

<span class="sd">    showit : bool, optional, default=True</span>
<span class="sd">        Whether to display the plot after saving. If False, the plot will be closed after saving.</span>

<span class="sd">    transparent_mode : bool, optional, default=False</span>
<span class="sd">        Whether to save the figure with a transparent background.</span>

<span class="sd">    figsize : tuple of float, optional, default=(5, 8)</span>
<span class="sd">        Size of the figure in inches.</span>

<span class="sd">    Outputs:</span>
<span class="sd">    --------</span>
<span class="sd">    The function saves the coefficient matrix plot in the directory specified by ./nico_out/niche_prediction_linear/.</span>
<span class="sd">    The filename will be in the format &quot;weight_matrix_R&lt;Radius&gt;.&lt;saveas&gt;&quot;, where &lt;Radius&gt; is the radius value</span>
<span class="sd">    from the input and &lt;saveas&gt; is the file format.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">fout</span><span class="p">,</span><span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">coef</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef&#39;</span><span class="p">]</span>
    <span class="n">cmn</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn&#39;</span><span class="p">]</span>
    <span class="n">cmn_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn_std&#39;</span><span class="p">]</span>
    <span class="n">coef_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef_std&#39;</span><span class="p">]</span>
    <span class="n">CTFeatures</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;CTFeatures&#39;</span><span class="p">]</span>
    <span class="n">classNames</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">classes</span><span class="p">)):</span>
        <span class="n">classNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

    <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="c1">#plt.figure()</span>
    <span class="c1">#snn.set(font_scale=0.4)</span>
    <span class="n">b</span><span class="o">=</span><span class="n">snn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">coef</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">yticklabels</span><span class="o">=</span><span class="n">CTFeatures</span><span class="p">,</span><span class="n">xticklabels</span><span class="o">=</span><span class="n">classNames</span><span class="p">)</span>
    <span class="c1">#plt.xticks(rotation=90)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">ylabels</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">()</span>
    <span class="n">b</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">ylabels</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">BothLinearAndCrossTerms</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Features linear  terms&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Features cross terms&#39;</span><span class="p">)</span>
    <span class="c1">#plt.xlabel(&#39;# of classes (no of cell types)&#39;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;R = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, C=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lambda_c</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;weight_matrix_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;weight_matrix_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_predicted_probabilities">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.plot_predicted_probabilities">[docs]</a>
<span class="k">def</span> <span class="nf">plot_predicted_probabilities</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">6</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate and save a plot of predicted probabilities from the results of spatial_neighborhood_analysis.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    input : dict, or similar object</span>
<span class="sd">            The main input is the output from spatial_neighborhood_analysis.</span>

<span class="sd">    saveas : str, optional, default=&#39;pdf&#39;</span>
<span class="sd">        Format to save the figure. Options are &#39;pdf&#39; or &#39;png&#39;. If &#39;png&#39;, the dpi is set to 300.</span>

<span class="sd">    showit : bool, optional, default=True</span>
<span class="sd">        Whether to display the plot after saving. If False, the plot will be closed after saving.</span>

<span class="sd">    transparent_mode : bool, optional, default=False</span>
<span class="sd">        Whether to save the figure with a transparent background.</span>

<span class="sd">    figsize : tuple of float, optional, default=(12, 6)</span>
<span class="sd">        Size of the figure in inches.</span>

<span class="sd">    Outputs:</span>
<span class="sd">    --------</span>
<span class="sd">    The function saves the plot of predicted probabilities in the directory specified by ./nico_out/niche_prediction_linear/.</span>
<span class="sd">    The filename will be in the format &#39;predicted_probability_R&lt;Radius&gt;.&lt;saveas&gt;&#39;, where &lt;Radius&gt; is the radius value</span>
<span class="sd">    from the input and &lt;saveas&gt; is the file format.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">snn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">x_train</span><span class="p">,</span><span class="n">xticklabels</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">inputFeatures</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;# of input Features&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;training set&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;75</span><span class="si">% o</span><span class="s1">f data&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">snn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">x_test</span><span class="p">,</span><span class="n">xticklabels</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">inputFeatures</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;# of input Features&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;testing set&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;25</span><span class="si">% o</span><span class="s1">f data&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">snn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">predicted_probs</span><span class="p">,</span><span class="n">xticklabels</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Predicted probability&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;# of classes (no of cell types)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;predicted_probability_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;predicted_probability_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>

    <span class="c1">#print(predicted_probs)</span>
    <span class="c1">#prob=sigmoid( np.dot([y_train, y_test,1], log_reg_model.coef_.T) + log_reg_model.intercept_ )</span>
    <span class="c1">#print(prob)</span>


<div class="viewcode-block" id="plot_roc_results">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.plot_roc_results">[docs]</a>
<span class="k">def</span> <span class="nf">plot_roc_results</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">nrows</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">ncols</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">),):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate and save ROC curves for the top 16 cell type predictions from the results of spatial_neighborhood_analysis.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    input : dict, or similar object</span>
<span class="sd">        The main input is the output from spatial_neighborhood_analysis.</span>

<span class="sd">    nrows : int, optional, default=4</span>
<span class="sd">        Number of rows in the subplot grid.</span>

<span class="sd">    ncols : int, optional, default=4</span>
<span class="sd">        Number of columns in the subplot grid.</span>

<span class="sd">    saveas : str, optional, default=&#39;pdf&#39;</span>
<span class="sd">        Format to save the figure. Options are &#39;pdf&#39; or &#39;png&#39;. If &#39;png&#39;, the dpi is set to 300.</span>

<span class="sd">    showit : bool, optional, default=True</span>
<span class="sd">        Whether to display the plot after saving. If False, the plot will be closed after saving.</span>

<span class="sd">    transparent_mode : bool, optional, default=False</span>
<span class="sd">        Whether to save the figure with a transparent background.</span>

<span class="sd">    figsize : tuple of float, optional, default=(10, 7)</span>
<span class="sd">        Size of the figure in inches.</span>

<span class="sd">    Outputs:</span>
<span class="sd">    --------</span>
<span class="sd">    The function saves the ROC curves plot in the directory specified by ./nico_out/niche_prediction_linear.</span>
<span class="sd">    The filename will be in the format &#39;ROC_R&lt;Radius&gt;.&lt;saveas&gt;&#39;, where &lt;Radius&gt; is the radius value</span>
<span class="sd">    from the input and &lt;saveas&gt; is the file format.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function creates a grid of ROC curves for the top 16 cell types with the highest ROC AUC values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">plotaxis</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">):</span>
            <span class="n">plotaxis</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>

    <span class="n">highestROCofcelltype</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">roc_auc</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">roc_auc</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1">#print(w, roc_auc[w])</span>
        <span class="n">highestROCofcelltype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="o">*</span><span class="n">ncols</span><span class="p">):</span>
        <span class="n">value</span><span class="o">=</span><span class="n">plotaxis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="p">(</span><span class="n">nrows</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;False Positive Rate&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>

        <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="n">ncols</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;True Positive Rate&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">highestROCofcelltype</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; : &#39;</span><span class="o">+</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">[</span><span class="n">highestROCofcelltype</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">fpr</span><span class="p">[</span><span class="n">highestROCofcelltype</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="nb">input</span><span class="o">.</span><span class="n">tpr</span><span class="p">[</span><span class="n">highestROCofcelltype</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;ROC(area = </span><span class="si">%0.2f</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">roc_auc</span><span class="p">[</span><span class="n">highestROCofcelltype</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>

        <span class="n">ax</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="c1">#ax[value[0],value[1]].grid(alpha=.4)</span>
    <span class="n">snn</span><span class="o">.</span><span class="n">despine</span><span class="p">()</span>
    <span class="c1">#plt.suptitle(&#39;Receiver operating characteristic example&#39;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;ROC_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span> <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;ROC_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>




<div class="viewcode-block" id="read_processed_data">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.read_processed_data">[docs]</a>
<span class="k">def</span> <span class="nf">read_processed_data</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span><span class="n">inputdir</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read and process the neighborhood expected feature matrix for spatial_neighborhood_analysis.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    radius : int or float</span>
<span class="sd">        The radius value used in the spatial analysis.</span>

<span class="sd">    inputdir : str</span>
<span class="sd">        The directory containing the input data file.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    neighborhoodClass : numpy.ndarray</span>
<span class="sd">        The matrix of neighborhood class features.</span>

<span class="sd">    target : numpy.ndarray</span>
<span class="sd">        The target labels (cell types).</span>

<span class="sd">    inputFeatures : range</span>
<span class="sd">        A range object representing the indices of the input features.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function reads a compressed `.npz` file containing the neighborhood expected feature matrix.</span>
<span class="sd">    - It filters out rows with NaN values.</span>
<span class="sd">    - It calculates the proportion of each cell type in the dataset.</span>
<span class="sd">    - The function returns the processed neighborhood class features, target labels, and input feature indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#name=inputdir+&#39;normalized_spatial_neighbors_&#39;+str(radius)+&#39;.dat&#39;</span>
    <span class="n">name</span><span class="o">=</span><span class="n">inputdir</span><span class="o">+</span><span class="s1">&#39;normalized_spatial_neighborhood_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.npz&#39;</span>
    <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data1</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;input_mat_for_log_reg&#39;</span><span class="p">]</span>
    <span class="c1">#data1 = np.genfromtxt(open(name, &quot;rb&quot;), delimiter=&#39;\t&#39;, skip_header=0)</span>
    <span class="n">ind</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span><span class="o">=</span><span class="n">data1</span><span class="p">[</span><span class="n">ind</span><span class="p">,:]</span>

    <span class="n">prop</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        <span class="n">mytype</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mytype</span> <span class="ow">in</span> <span class="n">prop</span><span class="p">:</span>
            <span class="n">prop</span><span class="p">[</span><span class="n">mytype</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prop</span><span class="p">[</span><span class="n">mytype</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

    <span class="c1">#print(&#39;cell type proportion&#39;)</span>
    <span class="n">total</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">keys</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span> <span class="n">prop</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="p">)</span>
    <span class="n">nct</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span>
    <span class="n">featureVector</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">nct</span><span class="p">)</span> <span class="c1"># #just neighborhood</span>
    <span class="n">neighborhoodClass</span><span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">featureVector</span><span class="p">]</span>
    <span class="n">target</span><span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;data shape&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;neighbor shape&quot;</span><span class="p">,</span><span class="n">neighborhoodClass</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">inputFeatures</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">nct</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">neighborhoodClass</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">inputFeatures</span></div>




<div class="viewcode-block" id="model_log_regression">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.model_log_regression">[docs]</a>
<span class="k">def</span> <span class="nf">model_log_regression</span><span class="p">(</span><span class="n">K_fold</span><span class="p">,</span><span class="n">n_repeats</span><span class="p">,</span><span class="n">neighborhoodClass</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">lambda_c</span><span class="p">,</span><span class="n">strategy</span><span class="p">,</span><span class="n">BothLinearAndCrossTerms</span><span class="p">,</span><span class="n">seed</span><span class="p">,</span><span class="n">n_jobs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform logistic regression classification to learn the probabilities of each cell type class. This helper function used in spatial_neighborhood_analysis.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    K_fold : int</span>
<span class="sd">        Number of folds for cross-validation.</span>

<span class="sd">    n_repeats : int</span>
<span class="sd">        Number of times the cross-validation is repeated.</span>

<span class="sd">    neighborhoodClass : numpy.ndarray</span>
<span class="sd">        Matrix of neighborhood class features.</span>

<span class="sd">    target : numpy.ndarray</span>
<span class="sd">        Target labels (cell types).</span>

<span class="sd">    lambda_c : list or numpy.ndarray</span>
<span class="sd">        Regularization strength(s) to be tested in the logistic regression.</span>

<span class="sd">    strategy : str</span>
<span class="sd">        The regularization and multi-class strategy. Options include &#39;L1_multi&#39;, &#39;L1_ovr&#39;, &#39;L2_multi&#39;, &#39;L2_ovr&#39;, &#39;elasticnet_multi&#39;, &#39;elasticnet_ovr&#39;.</span>

<span class="sd">    BothLinearAndCrossTerms : int</span>
<span class="sd">        Degree of polynomial features including interaction terms only.</span>

<span class="sd">    seed : int</span>
<span class="sd">        Random seed for reproducibility.</span>

<span class="sd">    n_jobs : int</span>
<span class="sd">        Number of jobs to run in parallel.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    log_reg_model : sklearn.linear_model.LogisticRegression</span>
<span class="sd">        The logistic regression model with specified parameters.</span>

<span class="sd">    parameters : dict</span>
<span class="sd">        Dictionary of parameters used for model training.</span>

<span class="sd">    hyperparameter_scoring : dict</span>
<span class="sd">        Dictionary of scoring metrics used for hyperparameter tuning.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function uses polynomial features to create interaction terms based on the specified degree.</span>
<span class="sd">    - Hyperparameter tuning is performed using cross-validation with f1_weighted scoring metrics.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">polynomial</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">degree</span> <span class="o">=</span> <span class="n">BothLinearAndCrossTerms</span><span class="p">,</span> <span class="n">interaction_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="c1">#hyperparameter_scoring=&#39;precision_weighted&#39;</span>
    <span class="c1">#hyperparameter_scoring=&#39;f1_micro&#39;</span>
    <span class="c1">#hyperparameter_scoring=&#39;recall_weighted&#39;</span>
    <span class="n">hyperparameter_scoring</span> <span class="o">=</span> <span class="p">{</span><span class="c1">#&#39;precision_weighted&#39;: make_scorer(precision_score, average = &#39;weighted&#39;),</span>
           <span class="c1">#&#39;precision_macro&#39;: make_scorer(precision_score, average = &#39;macro&#39;),</span>
           <span class="c1">#&#39;recall_macro&#39;: make_scorer(recall_score, average = &#39;macro&#39;),</span>
           <span class="c1">#&#39;recall_weighted&#39;: make_scorer(recall_score, average = &#39;weighted&#39;),</span>
           <span class="c1">#&#39;f1_macro&#39;: make_scorer(f1_score, average = &#39;macro&#39;),</span>
            <span class="c1">#&#39;log_loss&#39;:&#39;neg_log_loss&#39;,</span>
           <span class="s1">&#39;f1_weighted&#39;</span><span class="p">:</span> <span class="n">make_scorer</span><span class="p">(</span><span class="n">f1_score</span><span class="p">,</span> <span class="n">average</span> <span class="o">=</span> <span class="s1">&#39;weighted&#39;</span><span class="p">)}</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="n">lambda_c</span> <span class="p">}</span>

    <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;L1_multi&#39;</span><span class="p">:</span>
        <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;saga&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span><span class="c1">#very slow</span>
    <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;L1_ovr&#39;</span><span class="p">:</span>
        <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;liblinear&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;L2_multi&#39;</span><span class="p">:</span>
        <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;L2_ovr&#39;</span><span class="p">:</span>
        <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;elasticnet_multi&#39;</span><span class="p">:</span>
        <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;elasticnet&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;saga&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="n">lambda_c</span><span class="p">,</span> <span class="s1">&#39;multi_class&#39;</span><span class="p">:[</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span><span class="s1">&#39;multinomial&#39;</span><span class="p">],</span> <span class="s1">&#39;l1_ratio&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>  <span class="p">}</span>
    <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;elasticnet_ovr&#39;</span><span class="p">:</span>
        <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;elasticnet&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;saga&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="n">lambda_c</span><span class="p">,</span> <span class="s1">&#39;multi_class&#39;</span><span class="p">:[</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span><span class="s1">&#39;multinomial&#39;</span><span class="p">],</span> <span class="s1">&#39;l1_ratio&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>  <span class="p">}</span>


    <span class="c1">#&#39;&#39;&#39;</span>
    <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">how_many_times_repeat</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">sss</span> <span class="o">=</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">K_fold</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">1</span> <span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">gs_grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">log_reg_model</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="n">hyperparameter_scoring</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="s1">&#39;f1_weighted&#39;</span><span class="p">,</span><span class="n">cv</span><span class="o">=</span><span class="n">sss</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="c1">#gs_random = RandomizedSearchCV(estimator=log_reg_model, param_distributions=parameters, scoring=hyperparameter_scoring, refit=&#39;f1_weighted&#39;,cv = sss,n_jobs=n_jobs)</span>
        <span class="n">pipe_grid</span><span class="o">=</span><span class="n">Pipeline</span><span class="p">([</span>  <span class="p">(</span><span class="s1">&#39;polynomial_features&#39;</span><span class="p">,</span><span class="n">polynomial</span><span class="p">),</span>   <span class="p">(</span><span class="s1">&#39;StandardScaler&#39;</span><span class="p">,</span><span class="n">StandardScaler</span><span class="p">()),</span> <span class="p">(</span><span class="s1">&#39;logistic_regression_grid&#39;</span><span class="p">,</span><span class="n">gs_grid</span><span class="p">)])</span>
        <span class="c1">#pipe_random=Pipeline([  (&#39;polynomial_features&#39;,polynomial),   (&#39;StandardScaler&#39;,StandardScaler()), (&#39;logistic_regression_random&#39;,gs_random)])</span>
        <span class="n">pipe_grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">neighborhoodClass</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
        <span class="c1">#pipe_random.fit(neighborhoodClass,target)</span>

        <span class="n">LR_grid</span><span class="o">=</span> <span class="n">pipe_grid</span><span class="o">.</span><span class="n">named_steps</span><span class="p">[</span><span class="s1">&#39;logistic_regression_grid&#39;</span><span class="p">]</span>
        <span class="n">lambda_c</span><span class="o">=</span><span class="n">LR_grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lambda_c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">how_many_times_repeat</span><span class="p">:</span>
            <span class="n">how_many_times_repeat</span><span class="p">[</span><span class="n">lambda_c</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">how_many_times_repeat</span><span class="p">[</span><span class="n">lambda_c</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

        <span class="c1">#LR_random= pipe_random.named_steps[&#39;logistic_regression_random&#39;]</span>
        <span class="c1">#if LR_grid.best_params_[&#39;C&#39;]==LR_random.best_params_[&#39;C&#39;]:</span>
        <span class="c1">#print(&#39;Searching hyperparameters &#39;, &#39;Grid method:&#39;, LR_grid.best_params_[&#39;C&#39;], &#39;, Randomized method:&#39;, LR_random.best_params_[&#39;C&#39;])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Searching hyperparameters &#39;</span><span class="p">,</span> <span class="s1">&#39;Grid method:&#39;</span><span class="p">,</span> <span class="n">LR_grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">how_many_times_repeat</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">how_many_times_repeat</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Inverse of lambda regularization found&#39;</span><span class="p">,</span> <span class="n">lambda_c</span><span class="p">)</span>
    <span class="c1">#&#39;&#39;&#39;</span>
    <span class="c1">#lambda_c=0.000244140625</span>
    <span class="c1">#lambda_c=0.0009765625</span>




    <span class="n">scorecalc</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="n">scorecalc</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="n">cmn</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">coef</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">sss</span> <span class="o">=</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">K_fold</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="n">n_repeats</span> <span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">train_index</span><span class="p">,</span> <span class="n">test_index</span> <span class="ow">in</span> <span class="n">sss</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">neighborhoodClass</span><span class="p">,</span><span class="n">target</span><span class="p">):</span>
        <span class="n">x_train</span><span class="p">,</span><span class="n">x_test</span><span class="o">=</span><span class="n">neighborhoodClass</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span><span class="n">neighborhoodClass</span><span class="p">[</span><span class="n">test_index</span><span class="p">]</span>
        <span class="n">y_train</span><span class="p">,</span><span class="n">y_test</span><span class="o">=</span><span class="n">target</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span><span class="n">target</span><span class="p">[</span><span class="n">test_index</span><span class="p">]</span>


        <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;L1_multi&#39;</span><span class="p">:</span>
            <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">lambda_c</span><span class="p">,</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;saga&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span><span class="c1">#very slow</span>
        <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;L1_ovr&#39;</span><span class="p">:</span>
            <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">lambda_c</span><span class="p">,</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;liblinear&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;L2_multi&#39;</span><span class="p">:</span>
            <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">lambda_c</span><span class="p">,</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;L2_ovr&#39;</span><span class="p">:</span>
            <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">lambda_c</span><span class="p">,</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;elasticnet_multi&#39;</span><span class="p">:</span>
            <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">lambda_c</span><span class="p">,</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;elasticnet&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span><span class="n">l1_ratio</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;saga&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s1">&#39;elasticnet_ovr&#39;</span><span class="p">:</span>
            <span class="n">log_reg_model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">lambda_c</span><span class="p">,</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;elasticnet&#39;</span><span class="p">,</span><span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span><span class="n">l1_ratio</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;saga&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>

        <span class="n">pipe</span><span class="o">=</span><span class="n">Pipeline</span><span class="p">([</span>  <span class="p">(</span><span class="s1">&#39;polynomial_features&#39;</span><span class="p">,</span><span class="n">polynomial</span><span class="p">),</span>   <span class="p">(</span><span class="s1">&#39;StandardScaler&#39;</span><span class="p">,</span><span class="n">StandardScaler</span><span class="p">()),</span> <span class="p">(</span><span class="s1">&#39;logistic_regression&#39;</span><span class="p">,</span><span class="n">log_reg_model</span><span class="p">)])</span>

        <span class="n">pipe</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">y_pred</span><span class="o">=</span><span class="n">pipe</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
        <span class="n">y_prob</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>

        <span class="n">log_metric</span><span class="o">=</span><span class="n">log_loss</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_prob</span><span class="p">)</span>
        <span class="n">c_k_s</span><span class="o">=</span><span class="n">cohen_kappa_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)</span>
        <span class="n">zero_met</span><span class="o">=</span><span class="n">zero_one_loss</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)</span>
        <span class="n">hl</span><span class="o">=</span><span class="n">hamming_loss</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)</span>
        <span class="n">mcc</span><span class="o">=</span><span class="n">matthews_corrcoef</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)</span>

        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pipe</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
        <span class="c1">#precision, recall, fscore, support = score(y_test, predicted)</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;macro&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;macro&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;macro&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;micro&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;micro&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;micro&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">))</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_k_s</span><span class="p">)</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log_metric</span><span class="p">)</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mcc</span><span class="p">)</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hl</span><span class="p">)</span>
        <span class="n">scorecalc</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zero_met</span><span class="p">)</span>

        <span class="n">poly</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">named_steps</span><span class="p">[</span><span class="s1">&#39;polynomial_features&#39;</span><span class="p">]</span>
        <span class="n">LR</span><span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">named_steps</span><span class="p">[</span><span class="s1">&#39;logistic_regression&#39;</span><span class="p">]</span>
        <span class="n">coef</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LR</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
        <span class="n">cmn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">,</span><span class="n">normalize</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">))</span>

    <span class="n">cmn_std</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cmn</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">coef_std</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coef</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">comp_score_std</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scorecalc</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


    <span class="n">cmn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cmn</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">coef</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coef</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">comp_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scorecalc</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;training&#39;</span><span class="p">,</span><span class="n">x_train</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="s1">&#39;testing&#39;</span><span class="p">,</span><span class="n">x_test</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="s1">&#39;coeff&#39;</span><span class="p">,</span><span class="n">coef</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


    <span class="c1">#cmn=confusion_matrix(y_test,y_pred,normalize=&#39;true&#39;)</span>
    <span class="c1">#cmn = cm.astype(&#39;float&#39;) / cm.sum(axis=1)[:, np.newaxis]</span>
    <span class="n">classes</span><span class="o">=</span><span class="n">LR</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


    <span class="c1">#modifiedFeatures=range(1,len(CTFeatures)+1)</span>
    <span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">roc_auc</span><span class="o">=</span><span class="n">plot_multiclass_roc</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">n_classes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">))</span>

    <span class="n">CTFeatures</span><span class="o">=</span><span class="n">poly</span><span class="o">.</span><span class="n">get_feature_names_out</span><span class="p">()</span>
    <span class="c1">#print(&quot;Features&quot;, CTFeatures,type(CTFeatures))</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    print(&quot;accuracy score\t&quot;,np.mean(scorecalc[0]))</span>
<span class="sd">    print(&quot;\nmacro&quot;)</span>
<span class="sd">    print(&quot;f1 score\t&quot;,np.mean(scorecalc[1]))</span>
<span class="sd">    print(&quot;precision score\t&quot;,np.mean(scorecalc[2]))</span>
<span class="sd">    print(&quot;recall score\t&quot;,np.mean(scorecalc[3]))</span>

<span class="sd">    print(&quot;\nmicro f1, precision, recall all same&quot;)</span>
<span class="sd">    print(&quot;score\t&quot;,np.mean(scorecalc[4]))</span>
<span class="sd">    #print(&quot;precision score in 10 run\t&quot;,np.mean(scorecalc[5]))</span>
<span class="sd">    #print(&quot;recall score in 10 run\t&quot;,np.mean(scorecalc[6]))</span>

<span class="sd">    print(&quot;\nWeighted&quot;)</span>
<span class="sd">    print(&quot;f1 score\t&quot;,np.mean(scorecalc[7]))</span>
<span class="sd">    print(&quot;precision\t&quot;,np.mean(scorecalc[8]))</span>
<span class="sd">    print(&quot;recall score\t&quot;,np.mean(scorecalc[9]))</span>


<span class="sd">    print(&#39;\ncohen_kappa_score (best=1): {0:.4f}&#39;.format(np.mean(scorecalc[10])))</span>
<span class="sd">    print(&#39;log_loss or cross entropy (best=lowest): {0:.4f}&#39;.format(np.mean(scorecalc[11])))</span>
<span class="sd">    print(&#39;matthews_corrcoef: {0:.4f}&#39;.format( np.mean(scorecalc[12])  ))</span>
<span class="sd">    print(&#39;hemming_loss (best=lowest): {0:.4f}&#39;.format( np.mean(scorecalc[13] )))</span>
<span class="sd">    print(&#39;zero_one_loss (best=0): {0:.4f}&#39;.format(np.mean(scorecalc[14])))</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">cmn</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">comp_score</span><span class="p">,</span><span class="n">cmn_std</span><span class="p">,</span><span class="n">coef_std</span><span class="p">,</span><span class="n">comp_score_std</span><span class="p">,</span><span class="n">classes</span><span class="p">,</span> <span class="n">lambda_c</span><span class="p">,</span><span class="n">CTFeatures</span><span class="p">,</span><span class="n">x_test</span><span class="p">,</span><span class="n">x_train</span><span class="p">,</span><span class="n">y_prob</span> <span class="p">,</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">roc_auc</span></div>




<div class="viewcode-block" id="find_interacting_cell_types">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.find_interacting_cell_types">[docs]</a>
<span class="k">def</span> <span class="nf">find_interacting_cell_types</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">choose_celltypes</span><span class="o">=</span><span class="p">[],</span><span class="n">celltype_niche_interaction_cutoff</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="n">coeff_cutoff</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display regression coefficients indicating cell type interactions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    input : object</span>
<span class="sd">        The main input is the output from spatial_neighborhood_analysis.</span>

<span class="sd">    choose_celltypes : list, optional</span>
<span class="sd">        List of cell types to display the regression coefficients for.</span>
<span class="sd">        If empty, the output will be shown for all cell types.</span>
<span class="sd">        Default is [].</span>

<span class="sd">    celltype_niche_interaction_cutoff : float, optional</span>
<span class="sd">        The cutoff value to consider for cell type niche interactions for normalized coefficients. This is visualized by blue dotted line.</span>
<span class="sd">        Default is 0.1.</span>

<span class="sd">    coeff_cutoff : int, optional</span>
<span class="sd">        Maximum number of neighborhood cell types shown on the X-axis of the figures for each central cell type.</span>
<span class="sd">        If there are too many interacting cell types, choosing a more stringet cutoff limits the display to the cell types with the largest positive or negative regression coefficients to avoid crowding in the figure.</span>
<span class="sd">        Default is 20.</span>

<span class="sd">    saveas : str, optional</span>
<span class="sd">        Format to save the figures in, either &#39;pdf&#39; or &#39;png&#39;.</span>
<span class="sd">        Default is &#39;pdf&#39;.</span>

<span class="sd">    transparent_mode : bool, optional</span>
<span class="sd">        Background color of the figures.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    showit : bool, optional</span>
<span class="sd">        Whether to display the figures.</span>
<span class="sd">        Default is True.</span>

<span class="sd">    figsize : tuple, optional</span>
<span class="sd">        Dimension of the figure size.</span>
<span class="sd">        Default is (4.0, 2.0).</span>

<span class="sd">    Outputs:</span>
<span class="sd">    --------</span>
<span class="sd">    The figures are saved in ./nico_out/niche_prediction_linear/TopCoeff_R0/*</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function normalizes the coefficients by dividing by maximum and then it visualizes by blue dotted line.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">confusion_cutoff</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># no of cell types wants to print</span>
    <span class="n">filename</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;TopCoeff_R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span>

    <span class="n">nameOfCellType</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span>

    <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">fout</span><span class="p">,</span><span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">coef</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef&#39;</span><span class="p">]</span>
    <span class="n">cmn</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn&#39;</span><span class="p">]</span>
    <span class="n">cmn_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn_std&#39;</span><span class="p">]</span>
    <span class="n">coef_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef_std&#39;</span><span class="p">]</span>
    <span class="n">CTFeatures</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;CTFeatures&#39;</span><span class="p">]</span>
    <span class="n">coef</span><span class="o">=</span><span class="n">coef</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">coef</span><span class="p">))</span>
    <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cmn</span><span class="p">)</span>
    <span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cmn_std</span><span class="p">)</span>
    <span class="n">goodPredictedCellType</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
    <span class="n">create_directory</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="c1">#for i in range(len(goodPredictedCellType)):</span>
    <span class="c1">#    print(i,a[goodPredictedCellType[i]])</span>
    <span class="c1"># top 3 cell type in confusion matrix</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">goodPredictedCellType</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="o">&gt;=</span><span class="n">confusion_cutoff</span><span class="p">:</span>
            <span class="k">if</span>  <span class="n">nameOfCellType</span><span class="p">[</span><span class="n">goodPredictedCellType</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="ow">in</span> <span class="n">choose_celltypes</span><span class="p">:</span>
                <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">choose_celltypes</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>

            <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">meanCoefficients</span><span class="o">=</span><span class="n">coef</span><span class="p">[</span><span class="n">goodPredictedCellType</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                <span class="n">stdCoefficients</span><span class="o">=</span><span class="n">coef_std</span><span class="p">[</span><span class="n">goodPredictedCellType</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                <span class="n">highestIndex</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">meanCoefficients</span><span class="p">))</span>

                <span class="n">n</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">coeff_cutoff</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">highestIndex</span><span class="p">))</span>
                <span class="n">coeff_of_CT</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">name_of_the_coeff</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">std_of_coeff</span><span class="o">=</span><span class="p">[]</span>

                <span class="c1">#fw.write(&#39;\n&#39;+str(k+1)+ &#39; Largest predicted cell type and their top 5 coefficients : &#39;+</span>
                <span class="c1">#        nameOfCellType[goodPredictedCellType[k]]+&#39; ( id = &#39;+str(goodPredictedCellType[k])+&#39;,  confusion score = &#39;+str(&#39;%0.2f&#39;%a[goodPredictedCellType[k]])+&#39;)\n&#39;)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="c1">#for i in range(len(highestIndex)):</span>
                    <span class="n">l</span><span class="o">=</span><span class="n">CTFeatures</span><span class="p">[</span><span class="n">highestIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">temp</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
                        <span class="n">temp</span><span class="o">+=</span><span class="n">nameOfCellType</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span>
                        <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">temp</span><span class="o">+=</span><span class="s1">&#39;--&#39;</span>
                    <span class="c1">#print(temp,highestIndex[i],CTFeatures[highestIndex[i]],goodCoefficients[ highestIndex[i]   ])</span>
                    <span class="n">integerName</span><span class="o">=</span><span class="n">CTFeatures</span><span class="p">[</span><span class="n">highestIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="c1">#fw.write(str(highestIndex[i])+&#39;\t&#39;+str(&#39;%0.2f&#39;%meanCoefficients[ highestIndex[i]] ) +&#39;\t&#39;+temp+&#39; (&#39;+ integerName  +&#39;)\n&#39;)</span>
                    <span class="n">coeff_of_CT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meanCoefficients</span><span class="p">[</span> <span class="n">highestIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                    <span class="n">name_of_the_coeff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                    <span class="n">std_of_coeff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stdCoefficients</span><span class="p">[</span> <span class="n">highestIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

                <span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
                <span class="n">xx</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeff_of_CT</span><span class="p">))</span>
                <span class="n">yy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">coeff_of_CT</span><span class="p">)))</span>
                <span class="n">zz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeff_of_CT</span><span class="p">))</span><span class="o">*</span><span class="n">celltype_niche_interaction_cutoff</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">coeff_of_CT</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">std_of_coeff</span><span class="p">,</span><span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">markeredgewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">markeredgecolor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">capsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">elinewidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">capthick</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span><span class="c1">#markeredgecolor=&#39;blue&#39;,markerfacecolor=&#39;blue&#39;,</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">,</span><span class="s1">&#39;k-&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">zz</span><span class="p">,</span><span class="s1">&#39;b:&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
                <span class="c1">#ax.set_ylabel(&#39;value of coeff.&#39;)</span>
                <span class="c1">#ax.set_xlabel(&#39;name of the coeff.&#39;)</span>
                <span class="c1">#titlename=nameOfCellType[goodPredictedCellType[k]]+&#39;, conf score = {0:.3f}&#39;.format(a[goodPredictedCellType[k]]) +&#39;$\pm$&#39;+str(&#39;%0.3f&#39;%b[goodPredictedCellType[k]])</span>
                <span class="n">titlename</span><span class="o">=</span><span class="n">nameOfCellType</span><span class="p">[</span><span class="n">goodPredictedCellType</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="o">+</span><span class="s1">&#39;, conf. score = </span><span class="si">{0:.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">goodPredictedCellType</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span> <span class="o">+</span><span class="s1">&#39;$\pm$&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%0.3f</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">b</span><span class="p">[</span><span class="n">goodPredictedCellType</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>

                <span class="n">titlename</span><span class="o">=</span><span class="n">titlename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">titlename</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>


                <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name_of_the_coeff</span><span class="p">)):</span>
                    <span class="n">name_of_the_coeff</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">=</span><span class="n">name_of_the_coeff</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">name_of_the_coeff</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">():</span>
                    <span class="n">tick</span><span class="o">.</span><span class="n">set_rotation</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
                    <span class="n">tick</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>


                <span class="c1">#fig.tight_layout()</span>
                <span class="n">savefname</span><span class="o">=</span><span class="n">remove_extra_character_from_name</span><span class="p">(</span><span class="n">nameOfCellType</span><span class="p">[</span><span class="n">goodPredictedCellType</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">+</span><span class="s1">&#39;/Rank&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">savefname</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;/Rank&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">savefname</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def plot_celltype_nich_prediction_from_neighborhood_all_together(cmn,coef,cmn_std,coef_std,figuresize,filename):</span>
<span class="sd">            a=np.diag(cmn)</span>
<span class="sd">            b=np.diag(cmn_std)</span>
<span class="sd">            goodPredictedCellType=np.argsort(-a)</span>
<span class="sd">            create_directory(filename)</span>
<span class="sd">            fig,ax=plt.subplots( figsize=(figuresize[0],figuresize[1]))</span>
<span class="sd">            xx=range(len(coeff_of_CT))</span>
<span class="sd">            yy=np.zeros((len(coeff_of_CT)))</span>
<span class="sd">            ax.errorbar(xx, coeff_of_CT, yerr=std_of_coeff,fmt=&#39;o&#39;,markeredgewidth=0,markerfacecolor=None,markeredgecolor=None,linewidth=1,capsize=1,markersize=2,elinewidth=0.1,capthick=0.75)#markeredgecolor=&#39;blue&#39;,markerfacecolor=&#39;blue&#39;,</span>
<span class="sd">            ax.plot(xx,yy,&#39;k-&#39;,linewidth=0.2)</span>
<span class="sd">            #ax.set_ylabel(&#39;value of coeff.&#39;)</span>
<span class="sd">            #ax.set_xlabel(&#39;name of the coeff.&#39;)</span>
<span class="sd">            #titlename=nameOfCellType[goodPredictedCellType[k]]+&#39;, conf score = {0:.3f}&#39;.format(a[goodPredictedCellType[k]]) +&#39;$\pm$&#39;+str(&#39;%0.3f&#39;%b[goodPredictedCellType[k]])</span>
<span class="sd">            titlename=nameOfCellType[goodPredictedCellType[k]]+&#39;, id = &#39;+str(goodPredictedCellType[k])+&#39;, conf score = {0:.3f}&#39;.format(a[goodPredictedCellType[k]]) +&#39;$\pm$&#39;+str(&#39;%0.3f&#39;%b[goodPredictedCellType[k]])</span>

<span class="sd">            titlename=titlename.replace(&#39;_&#39;,&#39; &#39;)</span>
<span class="sd">            ax.set_title(titlename,fontsize=7)</span>


<span class="sd">            ax.set_xticks(xx)</span>
<span class="sd">            for ind in range(len(name_of_the_coeff)):</span>
<span class="sd">                name_of_the_coeff[ind]=name_of_the_coeff[ind].replace(&#39;_&#39;,&#39; &#39;)</span>
<span class="sd">            ax.set_xticklabels(name_of_the_coeff)</span>
<span class="sd">            for tick in ax.get_xticklabels():</span>
<span class="sd">                tick.set_rotation(90)</span>
<span class="sd">                tick.set_fontsize(7)</span>

<span class="sd">            #fig.tight_layout()</span>
<span class="sd">            savefname=remove_extra_character_from_name(nameOfCellType[goodPredictedCellType[k]])</span>
<span class="sd">            fig.savefig(filename+&#39;/Rank&#39;+str(k+1)+&#39;_&#39;+savefname+&#39;.pdf&#39;,bbox_inches=&#39;tight&#39;,transparent=True)</span>
<span class="sd">            fig.savefig(filename+&#39;/Rank&#39;+str(k+1)+&#39;_&#39;+savefname,bbox_inches=&#39;tight&#39;,transparent=True,dpi=300)</span>
<span class="sd">            fig.clf()</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="remove_extra_character_from_name">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.remove_extra_character_from_name">[docs]</a>
<span class="k">def</span> <span class="nf">remove_extra_character_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove special characters from cell type names to avoid errors while saving figures.</span>

<span class="sd">    This function replaces certain special characters in the input `name` with</span>
<span class="sd">    underscores or other appropriate characters to ensure the name is safe for use</span>
<span class="sd">    as a filename.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The original cell type name that may contain special characters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The modified cell type name with special characters removed or replaced.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; name = &#39;T-cell (CD4+)/CD8+&#39;</span>
<span class="sd">    &gt;&gt;&gt; clean_name = remove_extra_character_from_name(name)</span>
<span class="sd">    &gt;&gt;&gt; print(clean_name)</span>
<span class="sd">    &#39;T-cell_CD4p_CD8p&#39;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following replacements are made:</span>

<span class="sd">        - &#39;/&#39; is replaced with &#39;_&#39;</span>
<span class="sd">        - &#39; &#39; (space) is replaced with &#39;_&#39;</span>
<span class="sd">        - &#39;&quot;&#39; (double quote) is removed</span>
<span class="sd">        - &quot;&#39;&quot; (single quote) is removed</span>
<span class="sd">        - &#39;)&#39; is removed</span>
<span class="sd">        - &#39;(&#39; is removed</span>
<span class="sd">        - &#39;+&#39; is replaced with &#39;p&#39;</span>
<span class="sd">        - &#39;-&#39; is replaced with &#39;n&#39;</span>
<span class="sd">        - &#39;.&#39; (dot) is removed</span>

<span class="sd">    These substitutions help in creating filenames that do not contain characters</span>
<span class="sd">    that might be problematic for file systems or software.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">name</span></div>



<div class="viewcode-block" id="spatial_neighborhood_analysis">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.spatial_neighborhood_analysis">[docs]</a>
<span class="k">def</span> <span class="nf">spatial_neighborhood_analysis</span><span class="p">(</span>
<span class="n">output_nico_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="n">anndata_object_name</span><span class="o">=</span><span class="s1">&#39;nico_celltype_annotation.h5ad&#39;</span><span class="p">,</span>
<span class="n">spatial_cluster_tag</span><span class="o">=</span><span class="s1">&#39;nico_ct&#39;</span><span class="p">,</span><span class="n">spatial_coordinate_tag</span><span class="o">=</span><span class="s1">&#39;spatial&#39;</span><span class="p">,</span>
<span class="n">Radius</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="n">n_repeats</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="n">K_fold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="n">seed</span><span class="o">=</span><span class="mi">36851234</span><span class="p">,</span>
<span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
<span class="n">lambda_c_ranges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))),</span>
<span class="n">epsilonThreshold</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="n">removed_CTs_before_finding_CT_CT_interactions</span><span class="o">=</span><span class="p">[]):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform spatial neighborhood analysis to reconstruct the niche interaction patterns.</span>

<span class="sd">    This is the primary function called by the user to perform spatial neighborhood analysis, i.e., reconstruction of the niche.</span>

<span class="sd">    **Prerequisites:**</span>
<span class="sd">    Before calling this function, the user must have an annotation of the spatial cell from any method. This annotation is expected to comprise two files:</span>
<span class="sd">    `clusterFilename` that contains cells and cluster-ID information, and `celltypeFilename` that contains cluster-ID and cell type name information.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    output_nico_dir : str, optional</span>
<span class="sd">        Directory to save the output of niche interaction prediction.</span>
<span class="sd">        Default is &#39;./nico_out/&#39;.</span>

<span class="sd">    anndata_object_name : str, optional</span>
<span class="sd">        Name of the AnnData object file containing cell type annotations.</span>
<span class="sd">        Default is &#39;nico_celltype_annotation.h5ad&#39;.</span>

<span class="sd">    spatial_cluster_tag : str, optional</span>
<span class="sd">        Slot for spatial cluster information.</span>
<span class="sd">        Default is &#39;nico_ct&#39; that means it is stored in anndata.obs[&#39;nico_ct&#39;] slot.</span>

<span class="sd">    spatial_coordinate_tag : str, optional</span>
<span class="sd">        Slot for spatial coordinate information.</span>
<span class="sd">        Default is &#39;spatial&#39; that means it is stored in anndata.obsm[&#39;spatial&#39;] slot.</span>

<span class="sd">    Radius : int, optional</span>
<span class="sd">        Niche radius to predict the cell type-cell type interactions.</span>
<span class="sd">        Radius 0 focuses on direct spatial neighbors inferred by Delaunay triangulation, and</span>
<span class="sd">        nonzero Radius extends the neighborhood to include all cells within a given radius for predicting niche interactions.</span>
<span class="sd">        Default is 0.</span>

<span class="sd">    n_repeats : int, optional</span>
<span class="sd">        Number of times to repeat the logistic regression after finding the hyperparameters.</span>
<span class="sd">        Default is 1.</span>

<span class="sd">    K_fold : int, optional</span>
<span class="sd">        Number of cross-folds for the logistic regression.</span>
<span class="sd">        Default is 5.</span>

<span class="sd">    seed : int, optional</span>
<span class="sd">        Random seed used in RepeatedStratifiedKFold.</span>
<span class="sd">        Default is 36851234.</span>

<span class="sd">    n_jobs : int, optional</span>
<span class="sd">        Number of processors to use. See https://scikit-learn.org/stable/glossary.html#term-n_jobs for details.</span>
<span class="sd">        Default is -1.</span>

<span class="sd">    lambda_c_ranges : list, optional</span>
<span class="sd">        The initial range of the inverse regularization parameter used in the logistic regression to find the optimal parameter.</span>
<span class="sd">        Default is list(np.power(2.0, np.arange(-12, 12))).</span>

<span class="sd">    epsilonThreshold : int, optional</span>
<span class="sd">        Threshold value for neighboring cell during Delaunay Triangulation. This means those cells which are large then this cutoff cannot become neighbor at any cost.</span>
<span class="sd">        Default is 100.</span>

<span class="sd">    removed_CTs_before_finding_CT_CT_interactions : list, optional</span>
<span class="sd">        Exclude cell types from the niche interactions analysis.</span>
<span class="sd">        Default is [].</span>

<span class="sd">    **Outputs:**</span>

<span class="sd">    The function saves the output of niche interaction prediction in the specified &quot;nico_out&quot; directory.</span>

<span class="sd">    **Notes:**</span>

<span class="sd">    - Before running this function, ensure you have the cell type annotation files in the anndata object slot.</span>
<span class="sd">    - If running for multiple radius parameters, it&#39;s good practice to change the output directory name or delete the previously created one.</span>
<span class="sd">    - If the average number of neighbors is relatively low (&lt;1), consider increasing the radius for neighborhood analysis.</span>
<span class="sd">    - Every input CSV file (`positionFilename`, `clusterFilename`, `celltypeFilename`) must contain header information.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">output_nico_dir</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="n">output_nico_dir</span><span class="o">=</span><span class="s1">&#39;./nico_out/&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_nico_dir</span><span class="o">=</span><span class="n">output_nico_dir</span>

    <span class="n">BothLinearAndCrossTerms</span><span class="o">=</span><span class="mi">1</span><span class="c1"># If only linear terms then put 1; For both linear and crossterms use 2</span>
    <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;L2_multi&#39;</span> <span class="c1">#Name of the strategy you want to compute the interactions options are [L1_multi, L1_ovr, L2_multi, L2_ovr, elasticnet_multi, elasticnet_ovr]</span>
    <span class="c1">#strategy=&#39;L1_ovr&#39;</span>
    <span class="c1">#strategy=&#39;elasticnet_multi&#39;</span>
    <span class="n">removed_CTs_before_finding_CT_CT_interactions</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;NM&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">removed_CTs_before_finding_CT_CT_interactions</span>

    <span class="n">adata</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">output_nico_dir</span><span class="o">+</span><span class="n">anndata_object_name</span><span class="p">)</span>
    <span class="n">cellname</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="c1">#df.index.to_numpy()</span>
    <span class="n">cellname</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cellname</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellname</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">posdata</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cellname</span><span class="p">,</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="n">spatial_coordinate_tag</span><span class="p">]))</span>
    <span class="c1">#batch=np.vstack((cellname0,adata.obs[&#39;batch&#39;])).T</span>

    <span class="n">annot</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">spatial_cluster_tag</span><span class="p">]</span>
    <span class="n">ctname</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">annot</span><span class="p">)))</span>
    <span class="n">degbased_ctname</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ctname</span><span class="p">)):</span>
        <span class="n">degbased_ctname</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">ctname</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">d</span><span class="p">[</span><span class="n">ctname</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span>
    <span class="n">degbased_ctname</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">degbased_ctname</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="c1">#degbased_ctname[:,0]=degbased_ctname[:,0].astype(int)</span>

    <span class="n">degbased_cluster</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellname</span><span class="p">)):</span>
        <span class="n">degbased_cluster</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>  <span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">annot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="p">])</span>
    <span class="n">degbased_cluster</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">BothLinearAndCrossTerms</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">niche_pred_outdir</span><span class="o">=</span><span class="n">output_nico_dir</span><span class="o">+</span><span class="s1">&#39;niche_prediction_linear/&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">niche_pred_outdir</span><span class="o">=</span><span class="n">output_nico_dir</span><span class="o">+</span><span class="s1">&#39;niche_prediction_cross/&#39;</span>
    <span class="n">create_directory</span><span class="p">(</span><span class="n">niche_pred_outdir</span><span class="p">)</span>


    <span class="n">PP</span><span class="p">,</span><span class="n">cluster</span><span class="p">,</span><span class="n">noct</span><span class="p">,</span><span class="n">fraction_CT</span><span class="p">,</span><span class="n">clusterWithBarcodeId</span><span class="o">=</span> <span class="n">reading_data</span><span class="p">(</span><span class="n">posdata</span><span class="p">,</span><span class="n">degbased_cluster</span><span class="p">,</span><span class="n">degbased_ctname</span><span class="p">,</span><span class="n">output_nico_dir</span><span class="p">,</span><span class="n">removed_CTs_before_finding_CT_CT_interactions</span><span class="p">)</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="n">create_spatial_CT_feature_matrix</span><span class="p">(</span><span class="n">Radius</span><span class="p">,</span><span class="n">PP</span><span class="p">,</span><span class="n">cluster</span><span class="p">,</span><span class="n">noct</span><span class="p">,</span><span class="n">fraction_CT</span><span class="p">,</span><span class="n">niche_pred_outdir</span><span class="p">,</span><span class="n">epsilonThreshold</span><span class="p">)</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="n">output_nico_dir</span><span class="o">+</span><span class="s1">&#39;neighbors_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.p&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="n">output_nico_dir</span><span class="o">+</span><span class="s1">&#39;distances_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.p&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">clusterWithBarcodeId</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_nico_dir</span><span class="o">+</span><span class="s1">&#39;used_Clusters&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.csv&#39;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">output_nico_dir</span><span class="o">+</span><span class="s1">&#39;used_CT.txt&#39;</span><span class="p">)</span>
    <span class="n">nameOfCellType</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">l</span><span class="o">=</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">nameOfCellType</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>



    <span class="c1">#fw=open(mainoutputdir+&#39;prediction_R&#39;+str(Radius)+&#39;.dat&#39;,&#39;w&#39;)</span>
    <span class="c1">#fw.write(&#39;\nRadius = &#39;+ str(Radius)  + &#39;\n&#39;)</span>
    <span class="n">fout</span><span class="o">=</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;classifier_matrices_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.npz&#39;</span>

    <span class="n">inputdata</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;outputdir&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">output_nico_dir</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;fout&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">fout</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;niche_pred_outdir&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">niche_pred_outdir</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;nameOfCellType&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">nameOfCellType</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;Radius&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Radius</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;BothLinearAndCrossTerms&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">BothLinearAndCrossTerms</span>


    <span class="n">neighborhoodClass</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">inputFeatures</span><span class="o">=</span><span class="n">read_processed_data</span><span class="p">(</span><span class="n">Radius</span><span class="p">,</span><span class="n">niche_pred_outdir</span><span class="p">)</span>
    <span class="n">cmn</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">comp_score</span><span class="p">,</span><span class="n">cmn_std</span><span class="p">,</span><span class="n">coef_std</span><span class="p">,</span><span class="n">comp_score_std</span><span class="p">,</span><span class="n">classes</span><span class="p">,</span><span class="n">lambda_c</span><span class="p">,</span><span class="n">CTFeatures</span><span class="p">,</span><span class="n">x_test</span><span class="p">,</span><span class="n">x_train</span><span class="p">,</span><span class="n">predicted_probs</span><span class="p">,</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">roc_auc</span><span class="o">=</span><span class="n">model_log_regression</span><span class="p">(</span><span class="n">K_fold</span><span class="p">,</span> <span class="n">n_repeats</span><span class="p">,</span><span class="n">neighborhoodClass</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">lambda_c_ranges</span><span class="p">,</span><span class="n">strategy</span><span class="p">,</span><span class="n">BothLinearAndCrossTerms</span><span class="p">,</span><span class="n">seed</span><span class="p">,</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="n">score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">comp_score</span><span class="p">,</span> <span class="n">comp_score_std</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">fout</span><span class="p">,</span><span class="n">cmn</span><span class="o">=</span><span class="n">cmn</span><span class="p">,</span><span class="n">coef</span><span class="o">=</span><span class="n">coef</span><span class="p">,</span><span class="n">cmn_std</span><span class="o">=</span><span class="n">cmn_std</span><span class="p">,</span><span class="n">coef_std</span><span class="o">=</span><span class="n">coef_std</span><span class="p">,</span><span class="n">CTFeatures</span><span class="o">=</span><span class="n">CTFeatures</span><span class="p">)</span>

    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;classes&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">classes</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;lambda_c&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">lambda_c</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;fpr&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">fpr</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;tpr&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">tpr</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;roc_auc&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">roc_auc</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;x_test&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x_test</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;x_train&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x_train</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;predicted_probs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">predicted_probs</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;inputFeatures&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inputFeatures</span>
    <span class="n">inputdata</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">score</span>
    <span class="n">output</span><span class="o">=</span><span class="n">SimpleNamespace</span><span class="p">(</span><span class="o">**</span><span class="n">inputdata</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>












<div class="viewcode-block" id="plot_evaluation_scores">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.plot_evaluation_scores">[docs]</a>
<span class="k">def</span> <span class="nf">plot_evaluation_scores</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function generates and saves plots of evaluation scores obtained from the spatial_neighborhood_analysis.</span>
<span class="sd">    The plots can be saved in PDF or PNG format and can be displayed during execution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : dict or similar</span>
<span class="sd">        The main input is the output from spatial_neighborhood_analysis. This should contain the evaluation scores to be plotted.</span>
<span class="sd">    saveas : str, optional</span>
<span class="sd">        Format to save the figures. Options are &#39;pdf&#39; or &#39;png&#39;. Default is &#39;pdf&#39;.</span>
<span class="sd">    transparent_mode : bool, optional</span>
<span class="sd">        If True, the background color of the figures will be transparent. Default is False.</span>
<span class="sd">    showit : bool, optional</span>
<span class="sd">        If True, the figures will be displayed when the function is called. Default is True.</span>
<span class="sd">    figsize : tuple, optional</span>
<span class="sd">        Dimensions of the figure size in inches (width, height). Default is (4, 3).</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function saves the generated figures in the directory &quot;./nico_out/niche_prediction_linear/&quot; with filenames starting with &quot;scores&quot;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The order of scores saved in input.score as follows:</span>

<span class="sd">        - 1. accuracy</span>
<span class="sd">        - 2. macro F1</span>
<span class="sd">        - 3. macro precision</span>
<span class="sd">        - 4. macro recall</span>
<span class="sd">        - 5. micro F1</span>
<span class="sd">        - 6. micro precision</span>
<span class="sd">        - 7. micro recall</span>
<span class="sd">        - 8. weighted F1</span>
<span class="sd">        - 9. weighted precision</span>
<span class="sd">        - 10. weighted recall</span>
<span class="sd">        - 11. Cohen Kappa</span>
<span class="sd">        - 12. cross entropy</span>
<span class="sd">        - 13. mathhew correlation coefficient</span>
<span class="sd">        - 14. heming loss</span>
<span class="sd">        - 15. zeros one loss</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">xlabels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span><span class="s1">&#39;macro F1&#39;</span><span class="p">,</span><span class="s1">&#39;macro precision&#39;</span><span class="p">,</span><span class="s1">&#39;macro recall&#39;</span><span class="p">,</span><span class="s1">&#39;micro [all]&#39;</span><span class="p">,</span><span class="s1">&#39;weighted F1&#39;</span><span class="p">,</span><span class="s1">&#39;weighted precision&#39;</span><span class="p">,</span><span class="s1">&#39;weighted recall&#39;</span><span class="p">,</span><span class="s1">&#39;cohen kappa&#39;</span><span class="p">,</span><span class="s1">&#39;mcc&#39;</span><span class="p">]</span>
    <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>

    <span class="n">data</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">score</span>

    <span class="n">fig</span><span class="p">,</span><span class="n">axs</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="c1">#name=mainoutputdir+&#39;matrix_score_R&#39;+str(Radius)+&#39;.dat&#39;</span>
    <span class="c1">#data=np.genfromtxt(open(name, &quot;rb&quot;), delimiter=&#39;,&#39;, skip_header=0)</span>
    <span class="n">yt</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xt</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yt</span><span class="p">))</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span><span class="n">yt</span><span class="p">)</span><span class="c1">#,color=&#39;b&#39;)</span>
    <span class="n">lowRg</span><span class="o">=</span><span class="n">yt</span><span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">highRg</span><span class="o">=</span><span class="n">yt</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span><span class="n">yt</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="c1">#axs.fill_between(xt, lowRg, highRg,facecolor=&#39;b&#39;,alpha=0.2)</span>
    <span class="c1">#legend1= axs.legend(loc=&#39;lower left&#39;,bbox_to_anchor=(0.02, 0.05),ncol=1, borderaxespad=0., prop={&quot;size&quot;:6},fancybox=True, shadow=True)</span>

    <span class="n">axs</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)))</span>
    <span class="n">ytstd</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">yt</span><span class="p">)</span><span class="o">-</span><span class="n">ytstd</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">yt</span><span class="p">)</span><span class="o">+</span><span class="n">ytstd</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

    <span class="n">axs</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">xlabels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">axs</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">():</span>
        <span class="n">tick</span><span class="o">.</span><span class="n">set_rotation</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>

    <span class="n">axs</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;score&#39;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;scores_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;scores_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>



<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def plot_normalized_coefficients_radius_wise(inputRadius,BothLinearAndCrossTerms,inputdir,strategy,figuresize):</span>
<span class="sd">    f=open(inputdir+&#39;BiologicalNameOfCT.dat&#39;)</span>
<span class="sd">    nameOfCellType={}</span>
<span class="sd">    featureName=[]</span>
<span class="sd">    for line in f:</span>
<span class="sd">        l=line[0:-1].split(&#39;\t&#39;)</span>
<span class="sd">        nameOfCellType[int(l[0])]=l[1]</span>
<span class="sd">        featureName.append(l[1])</span>
<span class="sd">    savedir=mainoutputdir+&quot;RadiusWiseNormalizedCoefficients/&quot;</span>
<span class="sd">    create_directory(savedir)</span>

<span class="sd">    coef=[]</span>
<span class="sd">    confusion=[]</span>
<span class="sd">    for radius in inputRadius:</span>
<span class="sd">        fname=mainoutputdir+&#39;classifier_matrices_&#39;+str(radius)+&#39;.npz&#39;</span>
<span class="sd">        data=np.load(fname,allow_pickle=True)</span>
<span class="sd">        coef.append(data[&#39;coef&#39;])</span>
<span class="sd">        cmn=data[&#39;cmn&#39;]</span>
<span class="sd">        #cmn_std=data[&#39;cmn_std&#39;]</span>
<span class="sd">        #coef_std=data[&#39;coef_std&#39;]</span>
<span class="sd">        CTFeatures=data[&#39;CTFeatures&#39;]</span>
<span class="sd">        #coef.append(np.loadtxt(maindir+&#39;matrix_avg_coefficients_R&#39;+str(radius)+&#39;.dat&#39;,delimiter=&#39;,&#39;))</span>
<span class="sd">        #cmn=np.loadtxt(maindir+&#39;matrix_avg_confusion_R&#39;+str(radius)+&#39;.dat&#39;,delimiter=&#39;,&#39;)</span>
<span class="sd">        confusion.append(np.diagonal(cmn))</span>


<span class="sd">    coefSize=coef[0].shape</span>
<span class="sd">    coef=np.array(coef)</span>
<span class="sd">    C=np.array(confusion)</span>
<span class="sd">    B=np.einsum(&#39;kij-&gt;ikj&#39;,coef)</span>
<span class="sd">    #print(B.shape,C.shape)</span>


<span class="sd">    name_of_the_coeff=[]</span>
<span class="sd">    n=coefSize[1]</span>
<span class="sd">    for i in range(n):</span>
<span class="sd">        l=CTFeatures[i].split()</span>
<span class="sd">        temp=&#39;&#39;</span>
<span class="sd">        for j in range(len(l)):</span>
<span class="sd">            temp+=nameOfCellType[int(l[j][1:])]</span>
<span class="sd">            if j!=(len(l)-1):</span>
<span class="sd">                temp+=&#39;--&#39;</span>
<span class="sd">        name_of_the_coeff.append(temp)</span>


<span class="sd">    for i in range(len(B)):</span>
<span class="sd">        fig,ax=plt.subplots(1,1,figsize=(figuresize[0],figuresize[1]))</span>
<span class="sd">        for j in range(len(B[i])):</span>
<span class="sd">            value=np.max(abs(B[i][j]))</span>
<span class="sd">            B[i][j]=B[i][j]/value</span>
<span class="sd">        snn.heatmap(B[i],xticklabels=name_of_the_coeff)#,xticklabels=classes)</span>
<span class="sd">        ax.set_yticklabels(inputRadius,fontsize=5, rotation=0)</span>
<span class="sd">        ax.set_xticklabels(name_of_the_coeff,fontsize=5, rotation=90)</span>
<span class="sd">        ax.set_title(featureName[i] + &#39; [%0.2f&#39;%C[0,i] + &#39;, %0.2f]&#39;%C[-1,i]   ,fontsize=7)</span>
<span class="sd">        fig.tight_layout()</span>
<span class="sd">        fig.savefig(savedir+&#39;CT_&#39;+str(i+1)+ &#39;_&#39;+featureName[i]  + &#39;.png&#39;,bbox_inches=&#39;tight&#39;,dpi=300)</span>
<span class="sd">        fig.clf()</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="plot_niche_interactions_without_edge_weight">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.plot_niche_interactions_without_edge_weight">[docs]</a>
<span class="k">def</span> <span class="nf">plot_niche_interactions_without_edge_weight</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">niche_cutoff</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">)):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot niche interactions map without edge weights.</span>

<span class="sd">    This function generates and saves a niche interactions map using the output from spatial_neighborhood_analysis.</span>
<span class="sd">    The plot can be saved in PDF or PNG format and can be displayed during execution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : dict or similar</span>
<span class="sd">        The main input is the output from spatial_neighborhood_analysis. This should contain the necessary data to plot the niche interactions.</span>
<span class="sd">    niche_cutoff : float, optional</span>
<span class="sd">        Cutoff value for plotting the cell type niche interactions map. Default is 0.1.</span>
<span class="sd">    saveas : str, optional</span>
<span class="sd">        Format to save the figures. Options are &#39;pdf&#39; or &#39;png&#39;. Default is &#39;pdf&#39;.</span>
<span class="sd">    transparent_mode : bool, optional</span>
<span class="sd">        If True, the background color of the figures will be transparent. Default is False.</span>
<span class="sd">    showit : bool, optional</span>
<span class="sd">        If True, the figures will be displayed when the function is called. Default is True.</span>
<span class="sd">    figsize : tuple, optional</span>
<span class="sd">        Dimensions of the figure size in inches (width, height). Default is (10, 7).</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function saves the generated figures in the directory &quot;./nico_out/niche_prediction_linear/&quot; with filenames starting with &quot;Niche_interactions_*&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">fout</span><span class="p">,</span><span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">coef</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef&#39;</span><span class="p">]</span>
    <span class="n">cmn</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn&#39;</span><span class="p">]</span>
    <span class="n">cmn_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn_std&#39;</span><span class="p">]</span>
    <span class="n">coef_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef_std&#39;</span><span class="p">]</span>
    <span class="n">CTFeatures</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;CTFeatures&#39;</span><span class="p">]</span>

    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">)</span>
    <span class="n">top</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
    <span class="n">cumsum</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">newcmp</span><span class="o">=</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">cumsum</span><span class="p">))</span>
    <span class="c1">#newcmp=ListedColormap(top(np.linspace(0.95,0.15,n)),name=&quot;OrangeBlue&quot;)</span>
    <span class="n">gradientColor</span><span class="o">=</span><span class="n">newcmp</span><span class="o">.</span><span class="n">colors</span>
    <span class="c1">#print(len(gradientColor),len(top))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="c1">#coef=coef[0:3,0:19]</span>

    <span class="n">labeldict</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">)):</span>
        <span class="n">labeldict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">gradientColor</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1">#fig,ax=plt.subplots( figsize=figsize)</span>
    <span class="n">edges</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1">#print(&#39;coef&#39;,coef.shape, np.max(abs(coef)))</span>
    <span class="n">norm_coef</span><span class="o">=</span><span class="n">coef</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">coef</span><span class="p">))</span>

    <span class="n">largest</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">norm_coef</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">niche_cutoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">:</span>
                    <span class="c1">#edges.append([i,j,coef[i,j]])</span>
                    <span class="n">largest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm_coef</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">gradientColor</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">weight</span><span class="o">=</span><span class="n">norm_coef</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
    <span class="n">edge_labels</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span> <span class="s1">&#39;</span><span class="si">%0.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">])</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_pydot</span><span class="o">.</span><span class="n">graphviz_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="n">labeldict</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span><span class="n">linewidths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span><span class="n">node_color</span><span class="o">=</span><span class="n">gradientColor</span><span class="p">)</span>
    <span class="c1">#labels=nx.draw_networkx_labels(G,pos=pos,**options)</span>
    <span class="c1">#nx.draw(G,pos=pos,**options)</span>
    <span class="c1">#nx.draw_networkx_edge_labels(G, pos,edge_labels=edge_labels,label_pos=0.35, font_size=3  )</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;Niche_interactions_without_edge_weights_R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;Niche_interactions_without_edge_weights_R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>




<div class="viewcode-block" id="plot_niche_interactions_with_edge_weight">
<a class="viewcode-back" href="../../nico_interactions.html#nico_interactions.Interactions.plot_niche_interactions_with_edge_weight">[docs]</a>
<span class="k">def</span> <span class="nf">plot_niche_interactions_with_edge_weight</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">niche_cutoff</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">)):</span>
        <span class="c1">#niche_cutoff it is normalized large value has fewer connections and small value has larger connections</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot niche interactions map with edge weights.</span>

<span class="sd">        This function generates and saves a niche interactions map using the output from spatial_neighborhood_analysis. The edges in the map are weighted based on the interaction strengths. The plot can be saved in PDF or PNG format and can be displayed during execution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input : dict or similar</span>
<span class="sd">            The main input is the output from spatial_neighborhood_analysis. This should contain the necessary data to plot the niche interactions.</span>
<span class="sd">        niche_cutoff : float, optional</span>
<span class="sd">            Cutoff value for plotting the niche interactions map. Higher values result in fewer connections, while lower values result in more connections. Default is 0.1.</span>
<span class="sd">        saveas : str, optional</span>
<span class="sd">            Format to save the figures. Options are &#39;pdf&#39; or &#39;png&#39;. Default is &#39;pdf&#39;.</span>
<span class="sd">        transparent_mode : bool, optional</span>
<span class="sd">            If True, the background color of the figures will be transparent. Default is False.</span>
<span class="sd">        showit : bool, optional</span>
<span class="sd">            If True, the figures will be displayed when the function is called. Default is True.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            Dimensions of the figure size in inches (width, height). Default is (10, 7).</span>

<span class="sd">        Outputs</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The function saves the generated figures in the directory &quot;./nico_out/niche_prediction_linear/&quot; with filenames starting with &quot;Niche_interactions_*&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">fout</span><span class="p">,</span><span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">coef</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef&#39;</span><span class="p">]</span>
        <span class="n">cmn</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn&#39;</span><span class="p">]</span>
        <span class="n">cmn_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cmn_std&#39;</span><span class="p">]</span>
        <span class="n">coef_std</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;coef_std&#39;</span><span class="p">]</span>
        <span class="n">CTFeatures</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;CTFeatures&#39;</span><span class="p">]</span>

        <span class="c1">#print(coef.shape,len(CTFeatures))</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        meanCoefficients=coef[0]</span>
<span class="sd">        stdCoefficients=coef_std[0]</span>
<span class="sd">        #highestIndex=np.argsort(-abs(meanCoefficients))</span>

<span class="sd">        n=min(len(meanCoefficients))</span>
<span class="sd">        coeff_of_CT=[]</span>
<span class="sd">        name_of_the_coeff=[]</span>
<span class="sd">        std_of_coeff=[]</span>


<span class="sd">        for i in range(n):</span>
<span class="sd">            l=CTFeatures[i].split()</span>
<span class="sd">            temp=&#39;&#39;</span>
<span class="sd">            for j in range(len(l)):</span>
<span class="sd">                temp+=nameOfCellType[int(l[j][1:])]</span>
<span class="sd">                if j!=(len(l)-1):</span>
<span class="sd">                    temp+=&#39;--&#39;</span>
<span class="sd">        integerName=CTFeatures[i].replace(&#39;x&#39;,&#39;&#39;)</span>
<span class="sd">        coeff_of_CT.append(meanCoefficients[i])</span>
<span class="sd">        name_of_the_coeff.append(temp)</span>
<span class="sd">        std_of_coeff.append(stdCoefficients[i])</span>
<span class="sd">        #sklearn.cluster.bicluster</span>
<span class="sd">        linked=linkage(coef,&#39;single&#39;)</span>
<span class="sd">        #plt.figure(figsize=(10, 7))</span>
<span class="sd">        fig,ax=plt.subplots( figsize=(figsize_niche[0],figsize_niche[1]))</span>
<span class="sd">        dendrogram(linked,</span>
<span class="sd">            orientation=&#39;top&#39;,</span>
<span class="sd">            labels=nameOfCellType,</span>
<span class="sd">            distance_sort=&#39;descending&#39;,</span>
<span class="sd">            show_leaf_counts=True)</span>
<span class="sd">        #ax.set_xticks(xx)</span>
<span class="sd">        #ax.set_xticklabels(name_of_the_coeff)</span>
<span class="sd">        for tick in ax.get_xticklabels():</span>
<span class="sd">            tick.set_rotation(90)</span>

<span class="sd">        fig.savefig(mainoutputdir+&#39;HierarchicalClustering_Rad&#39;+str(Radius),bbox_inches=&#39;tight&#39;,dpi=300)</span>
<span class="sd">        plt.close(&#39;all&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">)</span>
        <span class="n">top</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
        <span class="n">cumsum</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">newcmp</span><span class="o">=</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">cumsum</span><span class="p">))</span>
        <span class="c1">#newcmp=ListedColormap(top(np.linspace(0.95,0.15,n)),name=&quot;OrangeBlue&quot;)</span>
        <span class="n">gradientColor</span><span class="o">=</span><span class="n">newcmp</span><span class="o">.</span><span class="n">colors</span>
        <span class="c1">#print(len(gradientColor),len(top))</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="c1">#coef=coef[0:3,0:19]</span>

        <span class="n">labeldict</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">)):</span>
            <span class="n">labeldict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">nameOfCellType</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">gradientColor</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">edges</span><span class="o">=</span><span class="p">[]</span>
        <span class="c1">#print(&#39;coef&#39;,coef.shape, np.max(abs(coef)))</span>
        <span class="n">norm_coef</span><span class="o">=</span><span class="n">coef</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">coef</span><span class="p">))</span>

        <span class="n">largest</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">norm_coef</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">niche_cutoff</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">:</span>
                        <span class="c1">#edges.append([i,j,coef[i,j]])</span>
                        <span class="n">largest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm_coef</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">gradientColor</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">weight</span><span class="o">=</span><span class="n">norm_coef</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                        <span class="c1">#print(i,nameOfCellType[i],nameOfCellType[j],coef[i,j]</span>
        <span class="c1">#G.add_edges_from([(1, 2,10), (1, 3,20)])</span>
        <span class="c1">#G.add_weighted_edges_from(edges)</span>


<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        #layout</span>
<span class="sd">        pos=nx.fruchterman_reingold_layout(G)</span>
<span class="sd">        pos=nx.circular_layout(G)</span>
<span class="sd">        pos=nx.random_layout(G)</span>
<span class="sd">        pos=nx.spectral_layout(G)</span>
<span class="sd">        pos=nx.spring_layout(G)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
        <span class="c1">#ncolor=[G[u][&#39;color&#39;] for u in G.nodes()]</span>

        <span class="c1">#edge_labels = dict([((n1, n2), f&#39;{n1}-&gt;{n2}&#39;) for n1, n2 in G.edges])</span>
        <span class="n">edge_labels</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span> <span class="s1">&#39;</span><span class="si">%0.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">])</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_pydot</span><span class="o">.</span><span class="n">graphviz_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>


        <span class="c1">#pos=nx.spring_layout(G)</span>
        <span class="c1">#pos=nx.circular_layout(G)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="n">labeldict</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
         <span class="n">linewidths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span><span class="n">node_color</span><span class="o">=</span><span class="n">gradientColor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span><span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">,</span><span class="n">label_pos</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">3</span>  <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;Niche_interactions_with_edge_weights_R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">niche_pred_outdir</span><span class="o">+</span><span class="s1">&#39;Niche_interactions_with_edge_weights_R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">Radius</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Grn lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>